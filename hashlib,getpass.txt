
دليل عملي سريع: الهاش، التشفير، getpass + دالة موحّدة للاستخدام اليومي
=====================================================================

🤝 الهدف
--------
ملف واحد يديك:
1) أساسيات الهاش اللي هتستخدمها كتير (مع خريطة سريعة لكل واحدة).
2) أساسيات التشفير القابل للفك (للبيانات—not كلمات السر).
3) استخدام getpass لإدخال كلمات السر بدون ما تظهر.
4) ملف/دوال جاهزة للاستعمال مباشرة: تخزين كلمة السر بأمان (هاش + Salt + تكرارات)،
   التحقق منها، تشفير/فك تشفير بيانات، ودالة موحّدة "ready-to-use".

⚠️ قاعدة ذهبية
--------------
- كلمات السر **لا تُشفَّر** بهدف التخزين. تُخزَّن كـ **هاش** مع **Salt** وتكرارات (KDF).
- **التشفير** مخصص لبيانات تريد استرجاعها لاحقًا (ملفات/نصوص سرية) وليس لكلمات السر.

---------------------------------------------------------------------
القسم 1) الهاش Hashing – المفاهيم الأساسية + خريطة سريعة
---------------------------------------------------------------------

ما هو الهاش؟
- دالة تحول بيانات لأي طول إلى بصمة ثابتة الطول.
- أحادي الاتجاه: لا يمكن الرجوع للنص الأصلي من الهاش مباشرة.
- يُستخدم للتحقق من كلمة السر بدون حفظها خام.

مصطلحات مهمة:
- Salt: قيمة عشوائية تُضاف قبل الهاش لمنع جداول القوس قزح (Rainbow Tables).
- KDF (مشتقات المفاتيح): خوارزميات تجعل عملية الهاش أبطأ عمدًا لزيادة الأمان (مثل PBKDF2, scrypt, Argon2).
- Iterations: عدد التكرارات داخل KDF؛ كلما زاد، كان أبطأ (وأكثر أمانًا حتى حد عملي).

خريطة/اختيارات شائعة (أين أستخدم ماذا؟)
- md5    → قديم وسريع لكن غير آمن ضد التصادمات. تجنّبه لكلمات السر.
- sha1   → أفضل قليلًا من md5 لكن غير موصى به لكلمات السر.
- sha256/sha512 → جيد للتحقق العام/سلامة البيانات، لكن **غير كافٍ وحده** لكلمات السر.
- PBKDF2-HMAC-SHA256 (builtin) → اختيار عملي ممتاز ومتوفر في بايثون بدون حزم خارجية.
- scrypt/Argon2/bcrypt       → خيارات قوية مخصصة لكلمات السر، تتطلب حزم إضافية.

توصية عملية:
- إن كنت تريد الاعتماد على المكتبات المدمجة فقط: استخدم **PBKDF2-HMAC-SHA256** مع Salt قوي وتكرارات عالية (مثال 100,000+).
- إن كان متاحًا تثبيت حزم: استخدم **Argon2** أو **bcrypt** لكلمات السر.

مثال سريع (hashlib + PBKDF2):
```python
import os, hashlib, binascii

def hash_password_pbkdf2(password: str, iterations: int = 150_000) -> str:
    salt = os.urandom(16)
    dk = hashlib.pbkdf2_hmac('sha256', password.encode(), salt, iterations)
    return f"pbkdf2_sha256${iterations}${binascii.hexlify(salt).decode()}${binascii.hexlify(dk).decode()}"

def verify_password_pbkdf2(password: str, stored: str) -> bool:
    scheme, iter_s, salt_hex, dk_hex = stored.split('$', 3)
    assert scheme == 'pbkdf2_sha256'
    iterations = int(iter_s)
    salt = binascii.unhexlify(salt_hex)
    dk_expected = binascii.unhexlify(dk_hex)
    dk = hashlib.pbkdf2_hmac('sha256', password.encode(), salt, iterations)
    # مقارنة ثابتة الوقت
    return hashlib.compare_digest(dk, dk_expected)

